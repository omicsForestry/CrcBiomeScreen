#' The packaging function for XGBoost modeling
#'
#' @param CrcBiomeScreenObject A \code{CrcBiomeScreenObject} containing normalized microbiome data, sample metadata, etc.
#' @param k.rf Set the number of cross validation
#' @param repeats Set the number of repeats in cross validation
#' @param TaskName A character string used to label the output
#' @param TrueLabel This label is the future prediction target
#' @param num_cores Set the number of the cores in parallel computing
#' @importFrom dplyr mutate across
#' @return CrcBiomeScreenObject
#' @export
#'
#' @examples CrcBiomeScreenObject <- ModelingXGBoost(
#'                                   CrcBiomeScreenObject = CrcBiomeScreenObject,
#'                                   k.rf = n_cv,
#'                                   TaskName = TaskName,
#'                                   TrueLabel = TrueLabel,
#'                                   num_cores = num_cores)
#'
ModelingXGBoost <- function(CrcBiomeScreenObject = NULL,
                            k.rf = 10,
                            repeats = 5,
                            TaskName = NULL,
                            TrueLabel = NULL,
                            num_cores = num_cores) {
  set.seed(123)
  # Parallel setup（memory friendly）
  cl <- makePSOCKcluster(num_cores)
  registerDoParallel(cl)
  getDoParWorkers()

  tune_grid <- expand.grid(
    nrounds = c(100, 200, 300),
    max_depth = c(3, 5, 7, 9),
    eta = c(0.01, 0.1, 0.3),
    gamma = 0,
    colsample_bytree = c(0.5, 0.75, 1),
    min_child_weight = 1,
    subsample = c(0.5, 0.75, 1)
  )
  # Prepare training data
  train_data <- CrcBiomeScreenObject$ModelData$Training
  label_train <- CrcBiomeScreenObject$ModelData$TrainLabel

  # label_train <- factor(label_train, levels = unique(CrcBiomeScreenObject$ModelData$TrainLabel))
  # # Suppose Positive is majority class.  Upweight Negative by ratio:
  # w_pos <- 1
  # w_neg <- nrow(train_data[train_data$Class=="Positive",]) /
  #         nrow(train_data[train_data$Class=="Negative",])
  # weights <- ifelse(train_data$Class=="Positive", w_pos, w_neg)

  class_counts <- table(label_train)
  positive_class <- names(which.max(class_counts))
  negative_class <- names(class_counts)[names(class_counts) != positive_class]

  w_pos <- 1
  w_neg <- nrow(train_data[label_train == positive_class, ]) /
    nrow(train_data[label_train == negative_class, ])
  weights <- ifelse(label_train == positive_class, w_pos, w_neg)

  # Define caret trainControl
  ctrl <- trainControl(
    method = "repeatedcv",
    number = k.rf,
    repeats = repeats,
    summaryFunction = twoClassSummary,
    classProbs = TRUE,
    allowParallel = TRUE
  )

  # model_weights <- model_weights[CrcBiomeScreenObject$ModelData$TrainLabel]

  train_data <- as.data.frame(train_data)
  train_data$label_train <- label_train

  set.seed(123)
  # Train the model using caret
  model_fit <- train(label_train ~ .,
    data = train_data,
    method = "xgbTree",
    metric = "ROC",
    trControl = ctrl,
    tuneGrid = tune_grid,
    weights = weights,
    verbose = TRUE
  )

  stopCluster(cl)
  registerDoSEQ()

  CrcBiomeScreenObject$ModelResult$XGBoost <- list(
    model = model_fit,
    bestTune = model_fit$bestTune
  )
  attr(CrcBiomeScreenObject$ModelResult$XGBoost, "TaskName") <- TaskName

  return(CrcBiomeScreenObject)
}
